<!DOCTYPE>
<html>
<head>
<title>Assembler for simple risc</title>
<link rel="stylesheet" href="main.css" type="text/css">
<meta http-equiv="author" content="sai">
</head>

<body>
<div class="container">
<h1>Simple Risc</h1>
	<h3>Basic Characteristics</h3>
	<ol>
	<li>It has 32-bit Instrunction register</li>
	<li>It has 21 instrunctions</li>
	<li>It has 2 flag bits</li>
	<li>It has 16 register (r0-r15)</li>
	<li>It has mainly two Data Instruction</li>
	<ul>
	<li>Register (R) Type Instruction</li>
	<li>Immediate (I) type instruction</li>
	</ul>
	<li>It can take at max three operands for one instruction</li>
	<ul>
	<li>One Destination Register and two Source Register</li>
	<li>One Destination Register and One Source Register</li>
	<li>One Destination Register and One immediate</li>
	<li>One Destination Register and One Source Register</li>
	<li>One Destination Register and One source Register and One Immediate</li>
	<li>No Operand</li>
	</ul>
	<li>The immediate instruction can have modifiers like u,h</li>
	</ol>

<h3>The category the  instrunction comes under :-</h3>
	<table>
		<tr>
		<th>Type of Operation</th>
		<th>Opcode</th>
		<th>Max No of Operands</th>
		<th>Code</th>
		<th>Code in decimal</th>
		</tr>
		<tr>
    <td>Data Transfer/Movement</td>
    <td>mov</td>
    <td></td>
    <td>01001</td>
    <td>9</td>
</tr>
<tr>
    <td>Data Transfer/Movement</td>
    <td>ld</td>
    <td></td>
    <td>01110</td>
    <td>14</td>
</tr>
<tr>
    <td>Data Transfer/Movement</td>
    <td>st</td>
    <td></td>
    <td>01111</td>
    <td>15</td>
</tr>
<tr>
    <td>Data Processing</td>
    <td>add</td>
    <td></td>
    <td>00000</td>
    <td>0</td>
</tr>
<tr>
    <td>Data Processing</td>
    <td>sub</td>
    <td></td>
    <td>00001</td>
    <td>1</td>
</tr>
<tr>
    <td>Data Processing</td>
    <td>mul</td>
    <td></td>
    <td>00010</td>
    <td>2</td>
</tr>
<tr>
    <td>Data Processing</td>
    <td>div</td>
    <td></td>
    <td>00011</td>
    <td>3</td>
</tr>
<tr>
    <td>Data Processing</td>
    <td>mod</td>
    <td></td>
    <td>00100</td>
    <td>4</td>
</tr>
<tr>
    <td>Data Processing</td>
    <td>cmp</td>
    <td></td>
    <td>00101</td>
    <td>5</td>
</tr>
<tr>
    <td>Data Processing</td>
    <td>and</td>
    <td></td>
    <td>00110</td>
    <td>6</td>
</tr>
<tr>
    <td>Data Processing</td>
    <td>or</td>
    <td></td>
    <td>00111</td>
    <td>7</td>
</tr>
<tr>
    <td>Data Processing</td>
    <td>not</td>
    <td></td>
    <td>01000</td>
    <td>8</td>
</tr>
<tr>
    <td>Data Processing</td>
    <td>lsl</td>
    <td></td>
    <td>01010</td>
    <td>10</td>
</tr>
<tr>
    <td>Data Processing</td>
    <td>lsr</td>
    <td></td>
    <td>01011</td>
    <td>11</td>
</tr>
<tr>
    <td>Data Processing</td>
    <td>asr</td>
    <td></td>
    <td>01100</td>
    <td>12</td>
</tr>
<tr>
    <td>Branch</td>
    <td>b</td>
    <td></td>
    <td>10010</td>
    <td>18</td>
</tr>
<tr>
    <td>Branch</td>
    <td>call</td>
    <td></td>
    <td>10011</td>
    <td>19</td>
</tr>
<tr>
    <td>Branch</td>
    <td>ret</td>
    <td></td>
    <td>10100</td>
    <td>20</td>
</tr>
<tr>
    <td>Branch</td>
    <td>beq</td>
    <td></td>
    <td>10000</td>
    <td>16</td>
</tr>
<tr>
    <td>Branch</td>
    <td>bgt</td>
    <td></td>
    <td>10001</td>
    <td>17</td>
</tr>
<tr>
    <td>Special</td>
    <td>nop</td>
    <td></td>
    <td>01101</td>
    <td>13</td>
</tr>
</table>


<h3>This is the table that has the opcode and Instruction and Format</h3> <!-- chathpt did the table code generation, don't feel sorry!!!!! -->
<table border="1">
    <tr>
        <th>Inst.</th>
        <th>Code</th>
        <th>Format</th>
        <th>Inst.</th>
        <th>Code</th>
        <th>Format</th>
    </tr>
    <tr>
        <td>add</td>
        <td>00000</td>
        <td>add rd, rs1, (rs2/imm)</td>
        <td>lsl</td>
        <td>01010</td>
        <td>lsl rd, rs1, (rs2/imm)</td>
    </tr>
    <tr>
        <td>sub</td>
        <td>00001</td>
        <td>sub rd, rs1, (rs2/imm)</td>
        <td>lsr</td>
        <td>01011</td>
        <td>lsr rd, rs1, (rs2/imm)</td>
    </tr>
    <tr>
        <td>mul</td>
        <td>00010</td>
        <td>mul rd, rs1, (rs2/imm)</td>
        <td>asr</td>
        <td>01100</td>
        <td>asr rd, rs1, (rs2/imm)</td>
    </tr>
    <tr>
        <td>div</td>
        <td>00011</td>
        <td>div rd, rs1, (rs2/imm)</td>
        <td>nop</td>
        <td>01101</td>
        <td>nop</td>
    </tr>
    <tr>
        <td>mod</td>
        <td>00100</td>
        <td>mod rd, rs1, (rs2/imm)</td>
        <td>ld</td>
        <td>01110</td>
        <td>ld rd.imm[rs1]</td>
    </tr>
    <tr>
        <td>cmp</td>
        <td>00101</td>
        <td>cmp rs1, (rs2/imm)</td>
        <td>st</td>
        <td>01111</td>
        <td>st rd.imm[rs1]</td>
    </tr>
    <tr>
        <td>and</td>
        <td>00110</td>
        <td>and rd, rs1, (rs2/imm)</td>
        <td>beq</td>
        <td>10000</td>
        <td>beq offset</td>
    </tr>
    <tr>
        <td>or</td>
        <td>00111</td>
        <td>or rd, rs1, (rs2/imm)</td>
        <td>bgt</td>
        <td>10001</td>
        <td>bgt offset</td>
    </tr>
    <tr>
        <td>not</td>
        <td>01000</td>
        <td>not rd, (rs2/imm)</td>
        <td>b</td>
        <td>10010</td>
        <td>b offset</td>
    </tr>
    <tr>
        <td>mov</td>
        <td>01001</td>
        <td>mov rd, (rs2/imm)</td>
        <td>call</td>
        <td>10011</td>
        <td>call offset</td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td></td>
        <td>ret</td>
        <td>10100</td>
        <td>ret</td>
    </tr>
</table>

<h2>Instruction Encoding</h3>
<p>These are the rules that have to be followed inorder to encode the instructions</p>
<p>The Instruction Register is 32bits</p>
<ol>
<li>The Opcode takes 5bits at the MSB of the instruction Register</li>
<li>The 6th MSB takes R/I bit value>
<ul>
<li>6th MSB is 0, meaning Register Type instrucntion, the format is 7th - 10th MSB takes the Destinatioin Register value, and The next four bits for first Source register and the next four for the second Register</p>
<li>6th MSB is 1, meaning Immediate type instruction, the format is 7th - 10th MSB is Destination Registerm, the Next 4 bits for the source Register, and next 18 bits for the Immediate value, and in these 18bits, first two bits are for the modifier and the last 16bits for the immediate value</li>
<p>Modifier Values and there significance
<table>
<tr>
    <th>15th MSB</th>
    <th>16th MSB</th>
    <th>Meaning</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>Default(2's complement)</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>u(unsigned)<td>
</tr><tr>
<td>1</td>
<td>0</td>
<td>h(higher order)<td>
</tr>

</table>
</ul>
<li>The 4bit value taken by registers is there own register number, meaning r1 - 0001, r15 - 1111</li>
</ol>
<h4>0-Address Instruction Encoding Format</h4>
Instructions:- <i>nop, ret </i>
<p>The first five bits are for the Opcode</p>
<p>The next 27 bits are empty meaning 0</p>
<h4>1-Address Instruction Encdoing</h4>
Instructions:- <i>call, b, beq, bgt</i>
<p>The first five bits are for the Opcode</p>
<p>The next 27 bits are for the relative address, we have to note here that modifiers doesn't make sense, as it is reltive offset and 27bits are total value</p>
<p>Meaning that PC(program counter) + offset*4, where offset is the 27bits immediate value</p>
<h4>3-Address Instruction Encoding Format</h4>
Instructions:- <i>add, sub, mul, div, mod, and, or, lsl, lsr, asr</i>
<p>The first five bits for the opcode</p>
<p>The 6th bit to specify whether instruction is R-Type or I-Type</p>
<p>If R-Type, 6th bit will be 0, then 7th - 10th bit will be Rd, 11th-14th will be Rs1 and 15th-19th will Rs2</p>
<p>here Rd will be Destination Register, Rs1 is first source register and Rs2 is second source register</p>
<p>If I-Type, 6th bit will be 1, then 7th - 10th bit will be Rd, 11th-14th bit will be Rs1 and 15th - 16th bit will be modifier, and next 16 bits will be immediate value</p>
<h4>2-Address Instructions Encoding format</h4>
Instructions: <i>cmp, not, mov</i>
<p>The first five bits will be opcode</p>
<p>For not and mov, the Rs1 place holder that is 11th -14th will be zero, for both R-type and I-type, in R-type Rd and Rs2 will be used, and in I-Type Rd and Immediate(last 18bits will be used)</p>
<p>For cmp, this opcode affects the flag, and influences the branch conditionals instructions, and the result of this is not stored in any destination register, hence only Rs1 and Rs2 will be used for R-Type, where I-Type it uses Rs1 and Immediate (last 18bits), now Rd will be zero for both cases</p>
<h4>ld and st instruction encoding</h4>
instruction:- <i>ld Rd, imm[rs1]</i>
<p>The format for this ld and st is, the first five bits are opcode, and Rd will be 7th to 10th bits, Rs1 will be 11th - 14th bits, and last 18 bits for the immediate value including modifier</p>


    <h1>Assembler Development Guidelines</h1>
    <blockquote>I have provided a out.txt file which has intger equivalent code of binary to ensure readibility for the user.</blockquote>

    <pre>

    </pre>
    <div class="section">
        <h2>1. Key Considerations</h2>
        <h3>1.1 Relative Addressing and ORG</h3>
        <ul>
            <li>Ensure correct handling of <strong>relative addressing</strong> for branch instructions.</li>
            <li>Manage the <strong>ORG directive</strong> to properly set the starting address.</li>
        </ul>

        <h3>1.2 Opcode and Operand Validation</h3>
        <ul>
            <li>Verify that all <strong>opcodes</strong> are valid.</li>
            <li>Ensure <strong>operands</strong> match their corresponding opcodes.</li>
            <li>Map operands to their <strong>respective codes</strong>.</li>
        </ul>

        <h3>1.3 Register Addressing Modes</h3>
        <ul>
            <li>Validate <strong>register addressing modes</strong> to ensure correct syntax and operation.</li>
        </ul>

        <h3>1.4 Modifiers Handling</h3>
        <ul>
            <li>Account for <strong>instruction modifiers</strong> if applicable.</li>
        </ul>

        <h3>1.5 Label Processing</h3>
        <ul>
            <li>Map <strong>labels</strong> with their respective instruction addresses.</li>
            <li>Handle <strong>label offsets</strong> correctly, considering whether the label appears before or after the referencing instruction.</li>
        </ul>

        <h3>1.6 Binary File Generation</h3>
        <ul>
            <li>Implemented proper conversion of instructions data into <strong>integer files</strong>, then convert to binary.</li>
        </ul>
    </div>

    <div class="section">
        <h2>2. Tasks Done</h2>
        <h3>2.1 Tokenization and Parsing</h3>
        <ul>
            <li>Completed the <strong>tokenization and parsing</strong> for <code>LD</code> and <code>ST</code> instructions. As they have different formats </li>
        </ul>

        <h3>2.2 Hexadecimal Input Validation</h3>
        <ul>
            <li>Ensure that each <strong>hexadecimal character</strong> is within the valid range (<code>0-9, a-f</code>). And max offset comes when branch instructions are used, 27bits input maximum is done, max allowed hex is 7ffffff</li>
        </ul>

        <h3>2.3 Label and Offset Considerations</h3>
        <ul>
            <li>When encountering a colon (<code>:</code>), treat it as a delimiter that <strong>precedes a label</strong>.</li>
            <li>Maintain a <strong>label holder</strong> to store the instruction number of each label.</li>
            <li>When a label is used as an operand in an instruction, match it with its stored instruction number to determine the offset.</li>
        </ul>

        <h3>2.4 Branch Instructions and Labels</h3>
        <ul>
            <li>Properly <strong>convert and process labels</strong> in branch instructions.</li>
            <li>If a <strong>label appears above</strong> the referencing instruction, the offset is <strong>negative</strong>.</li>
            <li>If a <strong>label appears below</strong> the referencing instruction, the offset is <strong>positive</strong>.</li>
        </ul>
    </div>

    <div class="section">
        <h2>3. Core Development Tasks</h2>
        <h3>3.1 Immediate Value Validation</h3>
        <ul>
            <li>The immediate value validation with respect to modifier and instructin based is taken care of.</li>
        </ul>

        <h3>3.2 Essential Functions</h3>
        <ul>
            <li><strong>Decimal to Binary Conversion</strong> – Implement a function to convert <strong>decimal numbers</strong> to binary.</li>
            <li><strong>Hexadecimal to Decimal</strong> – Implemented a function to convert <strong>hexadecimal numbers</strong> to decimals, to store in intermediate file called out.int.</li>
            <li><strong>Instruction-Label Mapping</strong> – Created a <strong>mapping mechanism</strong> to track labels and their corresponding instruction addresses.</li>
            <li><strong>Instruction Type Identification</strong> – Implemented logic to distinguish between <strong>R-type</strong> and <strong>I-type</strong> instructions.</li>
            <li><strong>Tokenization Implementation</strong> – Developed a tokenizer to process <strong>assembly instructions and labels</strong> effectively.</li>
        </ul>
    </div>

    <div class="section">
        <h2>4. Assembly Language Rules</h2>
        <h3>4.0 Assemble Language program should be stored in .txt only,To ensure proper encoding this was nessesary, if you want to have more extensioins then you have to change parameters in opcode_tokens.c file in github page or contact the developer </h3>
        <ul>
            <li>When compiling the code, please go to github repository for detailed assembler exectution process</li>
            <a href="https://github.com/sowhatnowgithub/Assembler_simple_risc"> Github page</a>
            <li>There is an intermediate file called out.int, which user can use to read the encoded instructions in integer for easy readability, the binary file will be generated based on this out.int file only</li>
        </ul>
        <h3>4.1 Immediate Value Formatting</h3>
        <ul>
            <li>Immediate values must be written in <strong>lowercase only</strong>.</li>
            <li>The correct format is <code>0x24ab</code>, ensuring both a <strong>prefix (0x)</strong> and a <strong>suffix (h) should not be added</strong>.</li>
            <li>Providing only <code>0x</code> without a value will result in an <strong>error</strong>.</li>
        </ul>

        <h3>4.2 Register Naming Convention</h3>
        <ul>
            <li>Registers must be named as <code>rX</code>, where <code>X</code> is a valid number between 0-15.</li>
            <li>Valid register names: <code>r3, r14</code></li>
            <li>Invalid register names: <code>r03, r130</code></li>
        </ul>

        <h3>4.3 Label Syntax Rules</h3>
        <ul>
            <li>Labels must be <strong>at most 9 characters long</strong>.</li>
            <li>A <strong>semicolon (:)</strong> must be placed <strong>at the end of the label name</strong>.</li>
        </ul>

        <h3>4.4 Sample Label and Branching Usage</h3>
        <pre> This is a valid:-
start:
    addu r1, r2, 0x3
    nop
    b skp
    nop
    b 0x1
    nop
    b start
skp:
    hlt

Example2: Valid:- label: b 0x1
Example3: Invalid Case: b ox1 label:
Example4: invalid Case: b label ox1
</pre>

        <h3>4.5 Encoding and Character Limits</h3>
        <ul>
            <li>Maximum <strong>instruction encodes</strong>: <code>999</code></li>
            <li>Maximum <strong>characters (excluding whitespace)</strong>: <code>30,000</code></li>
        </ul>
    </div>

    <div class="section">
        <h2>5. Summary</h2>
        <p>Following these guidelines ensures a well-structured assembler with <strong>accurate instruction processing, validation, and binary generation</strong>.</p>
    </div>

</body>
</html>
